<html>
<head>
<title>hpcviewer</title>
</head>
<body>
<h1>The hpcviewer User Interface </h1>
<p>
HPCToolkit provides the hpcviewer browser for interactive examination of 
performance databases. Figure 1 shows a screenshot of a brower window with 
panes and key controls labeled. The browser supports three different views 
of performance data. The browser window is divided into three panes. We 
first explain the views of performance data and then the role of the different 
panes. 
</p>

<center>
<img src="images/hpcviewer-legend.png" alt="hpcviewer flatview"/>
<br/>
Figure 1: A snapshot of hpcviewer
</center>

<h2>Views</h2>
<p> hpcviewer supports three principal views of an application's performance data: a top-down calling context view, a bottom-up caller's view, 
and a flat view. One selects the desired view by clicking on the corresponding 
view control tab. We briefly describe the three views and their corresponding 
purposes. 
</p>
<ul>
 <li> <b>Calling context view</b>. This top-down view represents the dynamic calling contexts (call paths) in which costs were incurred. Using this view, 
one can explore performance measurements of an application in a top- 
down fashion to understand the costs (We use the term cost rather than simply time since hpcviewer can present a multiplicity 
of measured (e.g. cycles, or cache misses) or derived metrics (e.g. cache miss rates or 
bandwidth consumed) that that are other indicators of execution cost.) incurred by calls to a procedure 
in a particular calling context. <br/>
A calling context for a procedure <b><code>f</code></b> consists of the stack of procedure frames active when the call was made to 
<b><code>f</code></b>. Using this view, one can readily see how much of the application's 
cost was incurred by <b><code>f</code></b> when called from a particular calling context. If 
finer detail is of interest, one can explore how the costs incurred by a call 
to <b><code>f</code></b> in a particular context are divided between <b><code>f</code></b> itself and the procedures
 it calls. HPCToolkit's call path profiler <i>hpcprof</i> and the hpcviewer 
user interface distinguish calling context precisely by individual call 
sites; this means that if a procedure <b><code>g</code></b> contains calls to procedure <b><code>f</code></b> in 
different places, these represent separate calling contexts.
</li> 
<li> <b>Callers view</b>. This bottom up view enables one to look upward along 
call paths. This view is particularly useful for understanding the performance of software components or procedures that are used in more 
than one context. For instance, a message-passing program may call 
<b><code>MPI_Wait</code></b> in many different calling contexts. The cost of any particular call will depend upon the structure of the parallelization in which 
 the call is made. 
 Serialization or load imbalance may cause long waits 
in some calling contexts while other parts of the program may have 
short waits because computation is balanced and communication is 
overlapped with computation. 
</li>
<li><b>Flat view</b>. This view organizes performance measurement data accord- 
ing to the static structure of an application. All costs incurred in any 
calling context by a procedure are aggregated together in the flat view. 
This complements the calling context view, in which the costs incurred 
by a particular procedure are represented separately for each call to 
the procedure from a different calling context. 
</li>
</ul>

<h2>Panes</h2>
<p>The browser window is divided into three panes: the <b>navigation</b> 
pane, the <b>source</b> pane, and the <b>metrics</b> pane. We briefly describe the role of 
each pane. </p>
<ul>
<li> <b>Source pane</b>. The source pane displays the source code associated with 
the current entity selected in the navigation pane. When a performance 
database is first opened with hpcviewer, the source pane is initially 
blank because no entity is selected in the navigation pane. Selecting 
any entity in the navigation pane will cause the source pane to load the 
corresponding file, scroll to and highlight the line corresponding to the 
selection. Switching the source pane to view to a different source file 
is accomplished by making another selection in the navigation pane. 
</li>
<li> <b>Navigation pane</b>. The navigation pane presents a hierarchical tree- 
based structure that is used to organize the presentation of an applications's 
 performance data. Entities that occur in the navigation pane's 
tree include load modules, files, procedures, procedure activations, inlined code, loops, and source lines. Selecting any of these entities will 
cause its corresponding source code (if any) to be displayed in the 
source pane. One can reveal or conceal children in this hierarchy by 
"opening" or "closing" any non-leaf (i.e., individual source line) entry 
in this view. 
<p>
The nature of the entities in the navigation pane's tree structure depends
 upon whether one is exploring the calling context view, the 
callers view, or the flat view of the performance data. 
</p>
<ul>
<li> In the <b>calling context view</b>, entities in the navigation tree represent 
procedure activations, inlined code, loops, and source lines. While 
most entities link to a single location in source code, procedure 
activations link to two: the call site from which a procedure was 
called and the procedure itself. </li>
<li> In the <b>callers view</b>, entities in the navigation tree are procedure 
activations. Unlike procedure activations in the calling context 
tree view in which call sites are paired with the called procedure, 
in the caller's view, call sites are paired with the calling procedure 
to facilitate attribution of costs for a called procedure to multiple 
different call sites and callers. </li>
<li> In the <b>flat view</b>, entities in the navigation tree correspond to source 
files, procedure call sites (which are rendered the same way as 
procedure activations), loops, and source lines. 
</li>
</ul>
<p>
The header above the navigation pane contains some controls for the 
navigation and metric view. In Figure 1, they are labeled as "navigation/metric control". 
<ul>
 <li><img src="images/Flatten.gif"/> <b>Flatten / <img src="images/Unflatten.gif"/> unflatten</b>: These buttons are only available for flat view. They enable one to flatten and unflatten 
the navigation hierarchy. Clicking on the flatten button (the icon that 
shows a tree node with a slash through it) will replace each top-level 
scope shown with its children. If a scope has no children (i.e., it is a 
leaf ), the node will remain in the view. This flattening operation is 
useful for relaxing the strict hierarchical view so that peers at the same 
level in the tree can be viewed and ranked together. For instance, this 
can be used to hide procedures in the flat view so that outermost loops 
can be ranked and compared to one another. The inverse of the flatten 
operation is the unflatten operation, which causes an elided node in 
the tree to be made visible once again. 
</li>
 <li><b><img src="images/Zoom in large.gif"/> Zoom-in/ <img src="images/Zoom out large.gif"/> Zoom-out</b>: Depressing the up arrow button will zoom in to show only information
for the selected line and its descendants. One can zoom out 
(reversing a prior zoom operation) by depressing the down arrow button</li>

 <li><img src="images/flameIcon.gif"/> <b>Hot call path</b>: This accounts for cost of performance hot-spots, and is used to show the chain of responsibility for costs.
 The "hot spot" is computed by comparing parent and child values, and show the chain where the difference is greater that a threshold 
 (by default is <code>50%</code>). It is also possible to change the threshold value by clicking the menu "File-Preference".</li>
 
 <li><img src="images/FnMetric.gif"/> <b>Derived metric</b>: Creating a new metric based on mathematics expression formula.</li>
 <li><img src="images/checkColumns.gif"/> <b>Show/hide metrics</b>: Showing and hiding metric columns. A dialog box will appear, and user can select which columns to show or hide.</li>
</ul>
</p>
</li>

<li> <b>Metric pane</b>. The metric pane displays one or more performance metrics associated with entities to the left in the navigation pane. Entities 
in the tree view of the navigation pane are sorted at each level of the 
hierarchy by the metric in the selected column. When <i>hpcviewer</i> is 
launched, the leftmost metric column is the default selection and the 
navigation pane is sorted according to the values of that metric in de- 
scending order. One can change the selected metric by clicking on a 
column header. Clicking on the header of the selected column toggles 
the sort order between descending and ascending. 
<p>
During analysis, one often wants to consider the relationship between 
two metrics. This is easier when the metrics of interest are in adjacent 
columns of the metric pane. One can change the order of columns in 
the metric pane by selecting the column header for a metric and then 
dragging it left or right to its desired position. The metric pane also 
includes scroll bars for horizontal scrolling (to reveal other metrics) 
and vertical scrolling (to reveal other scopes). Vertical scrolling of the 
metric and navigation panes is synchronized. 
</p>
</li>
</ul>

<h2>Understanding Metrics</h2>
<p>
The data gathered by profiler attributes the cost for each scope (a file, procedure, loop, or inlined function) exclusively. 
<i>hpcviewer</i> presents inclusive values for each cost metric associated with a program scope as well. 
Exclusive costs are those incurred by scope itself; whereas inclusive costs for a scope include costs incurred by 
any calls it makes. 
</p>

<h3>How metrics are computed ?</h3>
<p>Call path profile measurements collected by <i>hpcrun</i> correspond directly to the calling context view. <i>hpcviewer</i> 
derives all other views from exclusive metric costs in the calling context view. For the caller view, <i>hpcviewer</i> collects the 
cost of all samples in each function and attribute that to a top-level entry in the caller view. Under each top-level 
function, <i>hpcviewer</i> can look up the call chain at all of the context in which the function is called. For each function, <i>hpcviewer</i> 
apportions its costs among each of the calling contexts in which they were incurred. <i>hpcviewer</i> computes the flat view by 
traversing the calling context tree and attributing all costs for a scope to the scope within its static source code 
structure. The flat view presents a hierarchy of nested scopes from the load module, file, routine, loops, inlined 
code and statements. 
</p>

<h3>Example</h3>
<center>
<table>
<thead><tr><th>Figure 2a: file1.c</th><th>Figure 2b: file2.c</th></tr></thead>
<tbody>
<tr>
<td><pre>f () { 
 	g (); 
} 
// m is the main routine 
m () { 
 	f (); 
 	g (); 
} 
</pre></td>
<td><pre>// g can be a recursive function
g () { 
	if ( . . ) g (); 
	if ( . . ) h (); 
} 
h () { 
} 
</pre></td>
</tr>
</tbody>
</table>

<table>
<thead><tr><th>Figure 3: Calling context view</th></tr></thead>
<tbody>
<tr><td><img src="images/metrics-cct.png"></td></tr>
</tbody>
</table>

<table>
<thead><tr><th>Figure 4: Caller view</th></tr></thead>
<tbody>
<tr><td><img src="images/metrics-ct.png"></td></tr>
</tbody>
</table>

<table>
<thead><tr><th>Figure 5: Flat view</th></tr></thead>
<tbody>
<tr><td><img src="images/metrics-ft.png"></td></tr>
</tbody>
</table>

</center>
<p>
Figure 2 (a and b) shows an example of a recursive program separated into two files: <code>file1.c</code> and <code>file2.c</code> .
Routine <code>g</code> (Figure 2b) can behave as a recursive function depending on the value of the condition branch (Line 3-4).
Figure 3 shows an example of the call chain execution of the program annotated with both inclusive and exclusive costs. Computation of inclusive costs from exclusive costs in the calling context view involves simply summing up all of the costs in the subtree below.
</p>
<p>
In this figure, we can see that on the right path of the routine <code>m</code>, routine <code>g</code>
(instantiated in the diagram as <code>g<sub>1</sub></code>) performed a recursive call (<code>g<sub>2</sub></code>) before calling routine <code>h</code> (in this figure, we use numerical subscripts to distinguish between different instances of the same procedure. In the other parts of this figure, we use alphabetic subscripts. We use different labels because there is no natural one-to-one correspondence between the instances in the different views.) 
Although <code>g<sub>1</sub></code>, <code>g<sub>2</sub></code> and <code>g<sub>3</sub></code> are all instances from the same routine (i.e., <code>g</code>), we attribute  a different cost for each instance.
This separation of cost can be critical to identify which instance has a performance problem. 
</p>
<p>
Figure 4 shows the corresponding scope structure for the caller view and the costs we compute for this recursive program. The procedure <code>g</code> noted as <code>g<sub>a</sub></code> (which is a root node in the diagram), has different cost to <code>g</code> as a callsite as noted as <code>g<sub>b</sub></code>, <code>g<sub>c</sub></code> and <code>g<sub>d</sub></code>. 
For instance, on the first tree of this figure, the inclusive cost of  <code>g<sub>a</sub></code> is <code>9</code>, which is the sum of the highest  cost for each branch in calling context tree (Figure 3):  the inclusive cost of  <code>g<sub>3</sub></code> (which is <code>3</code>) and <code>g<sub>1</sub></code> (which is <code>6</code>).
We do not attribute the cost of <code>g<sub>2</sub></code> here since it is a descendant of <code>g<sub>1</sub></code> (in other term, the cost of <code>g<sub>2</sub></code> is included in <code>g<sub>1</sub></code>). 

</p>
<p>
Inclusive costs need to be computed similarly in the flat view. The inclusive cost of a recursive routine is the sum of the highest cost for each branch in calling context tree.
For instance, in Figure 5, The inclusive cost of <code>g<sub>x</sub></code>, defined as the total cost of all instances of <code>g</code>, is <code>9</code> and this is consistently the same as the cost in caller tree.
The advantage of attributing different cost for each instance of <code>g</code> is that it enables user to identify which instance is the responsible for performance losses.

</p>

<h2>Derived Metrics</h2>
<p>
Frequently, the data become useful only when combined with other information such as the number of instructions executed or 
the total number of cache accesses. 
While users don't mind a bit of mental arithmetic and frequently compare values in different 
columns to see how they relate for a scope, doing this for many scopes is exhausting. 
To address this problem, <i>hpcviewer</i> provides a mechanism for defining derived metrics. 
A derived metric is defined by specifying a spreadsheet-like mathematical formula that 
refers to data in other columns in the metric table by using <code>$n</code> to refer to the value in the <code>n</code><sup>th</sup> column.
</p>

</body>
</html>
