
package edu.rice.cs.hpc.data.experiment.metric.version3;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.LongBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileChannel.MapMode;
import java.util.Random;

import edu.rice.cs.hpc.data.util.Constants;
import edu.rice.cs.hpc.data.db.DataCommon;
import edu.rice.cs.hpc.data.experiment.BaseExperimentWithMetrics;
import edu.rice.cs.hpc.data.experiment.metric.BaseMetric;
import edu.rice.cs.hpc.data.experiment.metric.MetricValue;

/*********************************************
 * 
 * Class to handle summary.db file generated by hpcprof
 *
 *********************************************/
public class DataSummary extends DataCommon 
{
	// --------------------------------------------------------------------
	// constants
	// --------------------------------------------------------------------
	
	//private final static String SUMMARY_NAME = "hpctoolkit summary metrics";
	static final private int METRIC_ENTRY_SIZE = Constants.SIZEOF_FLOAT + Constants.SIZEOF_INT;
	static final public float DEFAULT_METRIC  = 0.0f;
	
	// --------------------------------------------------------------------
	// object variable
	// --------------------------------------------------------------------
	
	private long offset_start;
	private long offset_size;
	private long metric_start;
	private long metric_size;
	
	private int size_offset;
	private int size_metid;
	private int size_metval;

	private int []cct_table = null;
	
	private RandomAccessFile file;
	private FileChannel channel;

	
	// --------------------------------------------------------------------
	// Public methods
	// --------------------------------------------------------------------
	
	/***
	 *  <p>Opening for data summary metric file</p>
	 * (non-Javadoc)
	 * @see edu.rice.cs.hpc.data.db.DataCommon#open(java.lang.String)
	 */
	@Override
	public void open(final String file)
			throws IOException
	{
		super.open(file);
		
		open_internal(file);
		// fill the cct offset table
		fillOffsetTable(file);
	}
	

	@Override
	/*
	 * (non-Javadoc)
	 * @see edu.rice.cs.hpc.data.db.DataCommon#printInfo(java.io.PrintStream)
	 */
	public void printInfo( PrintStream out)
	{
		super.printInfo(out);
		out.println("Offset start: " + offset_start);
		out.println("Offset size: "  + offset_size);
		
		out.println("metric start: " + metric_start);
		out.println("metric size: "  + metric_size);
		
		out.println("size offset: "  + size_offset);
		out.println("size met id: "  + size_metid);
		out.println("size met val: " + size_metval);
		
		if (cct_table != null) 
		{
			for(int i=0; i<num_cctid; i++)
			{
				int num_metrics = (int) (cct_table[i+1] - cct_table[i]);
				out.format("%4x (%2d) ", cct_table[i], num_metrics);
				if (i % 16 == 15)
				{
					out.println();
				}
			}
			out.println("\n");
			int cct = 1;
			out.format("[%5d] ", cct);
			printMetrics(out, cct);

			// print random metrics
			for (int i=0; i<15; i++)
			{
				Random r = new Random();
				cct  = r.nextInt((int) num_cctid);
				out.format("[%5d] ", cct);
				printMetrics(out, cct);
			}
		}
	}
	
	/*******
	 * print a list of metrics for a given CCT index
	 * 
	 * @param out : the outpur stream
	 * @param cct : CCT index
	 */
	private void printMetrics(PrintStream out, int cct)
	{
		try {
			final ByteBuffer buffer = readMetrics(cct);
			if (buffer != null) {
				int offset_size   = (int) (cct_table[cct+1] - cct_table[cct]);
				int num_metrics   = offset_size / METRIC_ENTRY_SIZE; 
				for(int i=0; i<num_metrics; i++)
				{
					int my_metric_id = buffer.getInt();
					float metric_val = buffer.getFloat();
					out.format("%2d: %4.2e  ", my_metric_id, metric_val);
				}

			}
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		out.println();
	}
	
	
	/***********
	 * Reading a set of metrics from the file for a given CCT 
	 * This method does not support concurrency. The caller is
	 * responsible to handle mutual exclusion.
	 * 
	 * @param cct_id : CCT ID
	 * @return Byte buffer of the metrics
	 * @throws IOException
	 */
	private ByteBuffer readMetrics(int cct_id) throws IOException
	{
		int offset_size    = (int) (cct_table[cct_id+1] - cct_table[cct_id]);
		
		if (offset_size>0)
		{
			long offset 	   = (metric_start + cct_table[cct_id]);
			file.seek(offset);
			byte []metric_byte = new byte[offset_size];
			
			file.readFully(metric_byte);
			return ByteBuffer.wrap(metric_byte);
		}
		return null;
	}
	
	/**********
	 * Reading a set of metrics from the file for a given CCT 
	 * This method does not support concurrency. The caller is
	 * responsible to handle mutual exclusion.
	 * 
	 * @param cct_id
	 * @return
	 * @throws IOException
	 */
	public MetricValue[] getMetrics(int cct_id, BaseExperimentWithMetrics experiment) 
			throws IOException
	{
		ByteBuffer buffer = readMetrics(cct_id);
		if (buffer != null)
		{
			int offset_size    	= (int) (cct_table[cct_id+1] - cct_table[cct_id]);
			int num_metrics_cct = offset_size / METRIC_ENTRY_SIZE;
			int metric_size		= experiment.getMetricCount();
			
			MetricValue []metric_values = new MetricValue[(int) metric_size];
			for(int i=0; i<metric_size; i++)
			{
				metric_values[i] = MetricValue.NONE;
			}
			for(int i=0; i<num_metrics_cct; i++)
			{
				int my_metric_id = buffer.getInt();
				BaseMetric metric = experiment.getMetric(String.valueOf(my_metric_id));
				float metric_val = buffer.getFloat();
				metric_values[metric.getIndex()] = new MetricValue(metric_val);
			}
			return metric_values;
		}
		return null;
	}
	
	/*
	 * (non-Javadoc)
	 * @see edu.rice.cs.hpc.data.db.DataCommon#dispose()
	 */
	public void dispose() throws IOException
	{
		channel.close();
		file.close();
	}
	

	// --------------------------------------------------------------------
	// Protected methods
	// --------------------------------------------------------------------
	
	@Override
	protected boolean isTypeFormatCorrect(long type) {
		return type==1;
	}

	@Override
	protected boolean isFileHeaderCorrect(String header) {
		// suggestion from Mark: ignore the header file name
		return true; //header.startsWith(SUMMARY_NAME);
	}

	@Override
	protected boolean readNextHeader(FileChannel input) 
			throws IOException
	{
		ByteBuffer buffer = ByteBuffer.allocate(256);
		int numBytes      = input.read(buffer);
		if (numBytes > 0) 
		{
			buffer.flip();
			
			offset_start = buffer.getLong();
			offset_size  = buffer.getLong();
			metric_start = buffer.getLong();
			metric_size  = buffer.getLong();
			
			size_offset  = buffer.getInt();
			size_metid   = buffer.getInt();
			size_metval  = buffer.getInt();
		}		
		return false;
	}

	// --------------------------------------------------------------------
	// Private methods
	// --------------------------------------------------------------------
	
	private void fillOffsetTable(final String filename)
			throws IOException
	{
		// map all the table into memory. 
		// This statement can be problematic if the offset_size is huge
		
		MappedByteBuffer mappedBuffer = channel.map(MapMode.READ_ONLY, offset_start, offset_size);
		LongBuffer longBuffer = mappedBuffer.asLongBuffer();
		
		cct_table = new int[(int) num_cctid+1];
		
		for (int i=0; i<=num_cctid; i++)
		{
			cct_table[i] = (int) longBuffer.get(i);
		}
	}
	
	
	private void open_internal(String filename) throws FileNotFoundException
	{
		file 	= new RandomAccessFile(filename, "r");
		channel = file.getChannel();
	}

	/***************************
	 * unit test 
	 * 
	 * @param argv
	 ***************************/
	public static void main(String []argv)
	{
		final String DEFAULT_FILE = "/home/la5/data/new-database/db-lulesh-new/summary.db";
		final String filename;
		if (argv != null && argv.length>0)
			filename = argv[0];
		else
			filename = DEFAULT_FILE;
		
		final DataSummary summary_data = new DataSummary();
		try {
			summary_data.open(filename);			
			summary_data.printInfo(System.out);
			summary_data.dispose();	
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
